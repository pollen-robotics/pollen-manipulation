{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4bc7d95d-5d3b-4df3-8b37-214fccf579c7",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import time\n",
    "\n",
    "from pollen_manipulation.reachy_2.api import Reachy2ManipulationAPI\n",
    "\n",
    "from pollen_vision.camera_wrappers.depthai import SDKWrapper\n",
    "from pollen_vision.camera_wrappers.depthai.utils import get_config_file_path\n",
    "from pollen_vision.perception import Perception\n",
    "\n",
    "import FramesViewer.utils as fv_utils\n",
    "from reachy2_sdk import ReachySDK\n",
    "\n",
    "import numpy as np\n",
    "from pyquaternion import Quaternion\n",
    "import ipywidgets as widgets\n",
    "from IPython.display import display, clear_output\n",
    "\n",
    "from scipy.spatial.transform import Rotation as R\n",
    "\n",
    "T_world_cam = fv_utils.make_pose([0.049597, 0.009989, 0.038089], [0, 0, 0])\n",
    "T_world_cam[:3, :3] = np.array([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])\n",
    "T_world_cam = fv_utils.rotateInSelf(T_world_cam, [-48, 0, 0])\n",
    "\n",
    "cam = SDKWrapper(get_config_file_path(\"CONFIG_SR\"), compute_depth=True)\n",
    "\n",
    "K = cam.get_K()\n",
    "\n",
    "reachy = ReachySDK(host='localhost')\n",
    "manipulation_api = Reachy2ManipulationAPI(reachy, T_world_cam, K)\n",
    "\n",
    "perception = Perception(\n",
    "    camera_wrapper=cam, T_world_cam=T_world_cam, freq=10.0\n",
    ")\n",
    "perception.start(visualize=False)\n",
    "\n",
    "time.sleep(1.0)\n",
    "manipulation_api.turn_robot_on()\n",
    "time.sleep(1.0)\n",
    "manipulation_api.goto_rest_position(left=False)\n",
    "manipulation_api.goto_rest_position(left=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a18a2c7c-95cc-48e6-86b7-65a96a09de73",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_object_info():\n",
    "    object_info = [info for info in perception.get_objects_infos() if info['name'] == object_name and info['detection_score']>0.7]\n",
    "\n",
    "    if len(object_info) == 0:\n",
    "        print(f'No {object_name} found')\n",
    "        return []\n",
    "    \n",
    "    elif len(object_info) == 1:\n",
    "        bottle_info = object_info[0]\n",
    "        print(f'Found a {object_name}')\n",
    "        return object_info[0]\n",
    "    else:\n",
    "        print(f'Found {len(object_info)} {object_name}')\n",
    "        return []\n",
    "\n",
    "def compute_goal_diff(fk_matrix, goal_pose):\n",
    "    return np.linalg.norm(fk_matrix - selected_array)\n",
    "\n",
    "def compute_l2_distance(fk_matrix, goal_pose):\n",
    "    return np.linalg.norm(fk_matrix[:-1, 3] - goal_pose[:-1, 3])\n",
    "\n",
    "def compute_rotation_distance(fk_matrix, goal_pose):\n",
    "    q1 = Quaternion(matrix=fk_matrix[:3, :3])\n",
    "    Q, R = np.linalg.qr(goal_pose[:3, :3])\n",
    "    q2 = Quaternion(matrix=Q)\n",
    "    return Quaternion.distance(q1, q2)\n",
    "\n",
    "def produce_symetrical_poses(grasp_poses):\n",
    "    symetrical_grasp_poses = []\n",
    "\n",
    "    for grasp_pose in grasp_poses:\n",
    "        symetrical_grasp_pose = np.eye(4)\n",
    "        x, y, z = grasp_pose[:-1, 3]\n",
    "        symetrical_grasp_pose[:-1, 3] = [x, -y, z]\n",
    "\n",
    "        rotation_matrix = grasp_pose[:-1, :-1]\n",
    "        roll, pitch, yaw = R.from_matrix(rotation_matrix).as_euler(\"xyz\", degrees=True)\n",
    "        symetrical_grasp_pose[:-1, :-1] = R.from_euler(\"xyz\", [-roll, pitch, -yaw], degrees=True).as_matrix()\n",
    "        symetrical_grasp_poses.append(symetrical_grasp_pose)\n",
    "\n",
    "    return symetrical_grasp_poses\n",
    "\n",
    "# Define the initial pose matrices for each arm used by goto_rest_position API method\n",
    "right_start_pose = np.array([\n",
    "    [0.0, 0.0, -1.0, 0.20],\n",
    "    [0.0, 1.0, 0.0, -0.24],\n",
    "    [1.0, 0.0, 0.0, -0.23],\n",
    "    [0.0, 0.0, 0.0, 1.0],\n",
    "])\n",
    "left_start_pose = np.array([\n",
    "    [0.0, 0.0, -1.0, 0.20],\n",
    "    [0.0, 1.0, 0.0, 0.24],\n",
    "    [1.0, 0.0, 0.0, -0.23],\n",
    "    [0.0, 0.0, 0.0, 1.0],\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e1074af4-14b7-436c-ad1f-12512d63a8d5",
   "metadata": {},
   "outputs": [],
   "source": [
    "object_name = 'bottle'\n",
    "\n",
    "perception.set_tracked_objects([object_name])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a8d1c9d-2a77-44e1-9a57-c231edbd4c95",
   "metadata": {},
   "source": [
    "## Trigger grasping on fake robot\n",
    "Takes the first reachable grasp pose in the list generated by graspnet and perform grasping."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "76f50cf3-b304-442f-b036-1b76886aaf5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "object_info = get_object_info()\n",
    "\n",
    "if object_info == []:\n",
    "    print(\"Can't try grasping\")\n",
    "else:\n",
    "    manipulation_api.grasp_object(object_info, left=True)\n",
    "    manipulation_api.goto_rest_position(left=True, open_gripper=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30506ae2-595b-41e8-b65e-18d4e54327bb",
   "metadata": {},
   "source": [
    "## Get all reachable grasp poses candidates\n",
    "\n",
    "First, get the list of all the reachable grasp poses. The rest position is also inserted as first position so that it is possible to put the arm back to the rest position with the slider when viewing the grasp pose candidates.\n",
    "\n",
    "A list with symetrical grasp poses is also generated. The symmetry of a given grasp pose for an arm is such that the other arm should end up in the same position as if it was with a mirror. Having this was useful to check the symmetry of both arms."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4bf7a6ba-d1b3-43aa-9391-602101efb2a1",
   "metadata": {},
   "outputs": [],
   "source": [
    "object_info = get_object_info()\n",
    "\n",
    "if object_info == []:\n",
    "    print(\"Can't get reachable grasp poses\")\n",
    "else:\n",
    "    pose = object_info[\"pose\"]\n",
    "    rgb = object_info[\"rgb\"]\n",
    "    mask = object_info[\"mask\"]\n",
    "    depth = object_info[\"depth\"]\n",
    "\n",
    "    # Put this flag to False if you want to grasp with the right arm\n",
    "    left = True\n",
    "\n",
    "    if left:\n",
    "        arm = manipulation_api.reachy.l_arm\n",
    "        symetrical_arm = manipulation_api.reachy.r_arm\n",
    "        start_pose = left_start_pose\n",
    "        \n",
    "    else:\n",
    "        arm = manipulation_api.reachy.r_arm\n",
    "        symetrical_arm = manipulation_api.reachy.l_arm\n",
    "        start_pose = right_start_pose\n",
    "    \n",
    "    grasp_poses, _ = manipulation_api.get_reachable_grasp_poses(rgb, depth, mask, left)\n",
    "    grasp_poses.insert(0, start_pose)\n",
    "    \n",
    "    symetrical_grasp_poses = produce_symetrical_poses(grasp_poses)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "46ce879d-7969-400b-91a0-1d9d4c5e4432",
   "metadata": {},
   "source": [
    "## Iterate over each reachable grasp pose candidate\n",
    "\n",
    "Using the slider, iterate over each reachable grasp pose and send it to the fake robot to visualize what would be the movement of the arm in rviz.\n",
    "\n",
    "Once the grasp pose reached, the l2 distance between the actual cartesian coordinates of the effector and the one from the grasp pose is computed. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3c285848-8e6a-4bb0-8625-d4584d8146cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "slider = widgets.IntSlider(\n",
    "    value=0,\n",
    "    min=0,\n",
    "    max=len(grasp_poses) - 1,\n",
    "    step=1,\n",
    "    description='Tableau:',\n",
    "    orientation='horizontal',\n",
    ")\n",
    "\n",
    "# Bouton pour exécuter l'action\n",
    "button = widgets.Button(description=\"Send goal pose\")\n",
    "\n",
    "# Zone de sortie pour afficher les résultats\n",
    "output = widgets.Output()\n",
    "\n",
    "def on_slider_change(change):\n",
    "    with output:\n",
    "        clear_output()\n",
    "        selected_index = change['new']\n",
    "        selected_array = grasp_poses[selected_index]\n",
    "        print(f\"Tableau {selected_index}:\")\n",
    "        print(selected_array)\n",
    "        \n",
    "        goto_id = arm.goto_from_matrix(selected_array)\n",
    "\n",
    "        if goto_id != -1:\n",
    "            while not manipulation_api.reachy.is_move_finished(goto_id):\n",
    "                time.sleep(0.1)\n",
    "\n",
    "            time.sleep(1.0)\n",
    "\n",
    "            joints_pos = arm.get_joints_positions()\n",
    "            fk = arm.forward_kinematics()\n",
    "        \n",
    "            l2_dist = compute_l2_distance(fk, selected_array)\n",
    "            print(f'l2 dist: {l2_dist}')\n",
    "\n",
    "        ## Uncomment the lines below to send symmetric grasp poses to the other arm\n",
    "\n",
    "        # goto_id = symetrical_arm.goto_from_matrix(symetrical_grasp_poses[selected_index])\n",
    "        # if goto_id != -1:\n",
    "        #     while not manipulation_api.reachy.is_move_finished(goto_id):\n",
    "        #         time.sleep(0.1)\n",
    "\n",
    "        #     time.sleep(1.0)\n",
    "        #     sym_fk = symetrical_arm.forward_kinematics()\n",
    "        \n",
    "        #     l2_dist = compute_l2_distance(sym_fk, symetrical_grasp_poses[selected_index])\n",
    "        #     print(f'l2 dist for symetrical arm: {l2_dist}')\n",
    "        #     print(symetrical_grasp_poses[selected_index])\n",
    "\n",
    "# Associer la fonction de changement de valeur au slider\n",
    "slider.observe(on_slider_change, names='value')\n",
    "\n",
    "# Afficher les widgets\n",
    "display(slider, output)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c41b683f-1223-434f-9652-95d27c87e147",
   "metadata": {},
   "outputs": [],
   "source": [
    "grasp_poses[4]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c09c9a4a-de88-4199-9435-e2399db1e415",
   "metadata": {},
   "outputs": [],
   "source": [
    "manipulation_api.goto_rest_position(left=True)\n",
    "manipulation_api.goto_rest_position(left=False)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
